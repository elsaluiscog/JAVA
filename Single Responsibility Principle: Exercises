/*  Exercise-1  ‚ñ∏  SINGLE-RESPONSIBILITY  (SRP)
 *  One class is doing too much: domain logic, I/O, and presentation.
 *  TODO: Split this file into focused classes so each has only one reason to change.
 */
import java.io.*;
import java.math.BigDecimal;
import java.nio.file.*;
import java.util.*;

public class Invoice {
    private final List<LineItem> items = new ArrayList<>();

    public void addItem(LineItem li) { items.add(li); }

    public BigDecimal total() {
        return items.stream()
                    .map(LineItem::subtotal)
                    .reduce(BigDecimal.ZERO, BigDecimal::add);
    }

}

    // persistence + presentation mixed in!
    public class Saver {
        public void save(Path path) throws IOException {
            Files.writeString(path, toString());
    }
}


    public class Printer{
        public void print() {
            System.out.println("--- Invoice ---");
            invoice.getitems().forEach(System.out::println);
            System.out.println("Total: " + total());
    }
}


public record LineItem(String name, int qty, BigDecimal price) {
    public BigDecimal subtotal() { return price.multiply(BigDecimal.valueOf(qty)); }
}




/*  Exercise-2  ‚ñ∏  OPEN/CLOSED  (OCP)
 *  `AreaCalculator` must change every time a new shape appears.
 *  TODO: Refactor so you can add new shapes without modifying AreaCalculator.

 */
public interface Shape {double area(); }

public class Circle implements Shape {
private final double r;
public Circle(double r( {this.r -r;}
public double area() { return Math.PI * r * r; }

}


Public class Rectangle implements Shape {
private final double w,h;
public Rectangle(double w, double h) {this.w = w, this.h = h;}
public double area () {return w * h}
}

public class AreaCalculator {
    public double area(List<Shape> shapes) {
        return shapes.stream().mapToDouble(Shape::area).sum();
}
}








/*  Exercise-3  ‚ñ∏  LISKOV SUBSTITUTION  (LSP)
 *  Square inherits setters that break the base‚Äêclass contract.
 *  TODO: Remove the violation so any Rectangle variable still works if
 *        bound to a Square.
 */

public interface Resize {
void setWidth(int w);
void setHeight(int h);
double area();

}
class Rectangle {
    protected int w,h;
    public void setWidth(int w)  { this.w = w; }
    public void setHeight(int h) { this.h = h; }
    public int  area()           { return w*h; }
}

class Square {
    protected int side;
    public void setWidth(int w)  { this.w = w; }
    public void setHeight(int h) { this.h = h; }
    public int  area()           { return side  * side; }
}

class Square extends Rectangle {
    @Override void setWidth(int s)  { w = h = s; }
    @Override void setHeight(int s) { w = h = s; }
}




/*  Exercise-4  ‚ñ∏  INTERFACE SEGREGATION  (ISP)
 *  Clients that only print are forced to depend on scan/fax.
 *  TODO: Break the bloated interface into smaller, role-specific ones.
 */

public interface Printer { void print(Document d); }
public interface Scanner {void scan(Document d); }
public interface Fax { void fax(Document d);}


public class LaserPrinter implements Printer { void print(Document d)}
public class LaserScanner implements Scanner { void print(Document d)}
public class LaserFax implements Fax { void print(Document d)}


public class MultiFunctionPrinter implements Printer, Scanner, Fax {
    public void print(Document d) { /* ... */ }
    public void scan(Document d)  { /* ... */ }
    public void Fax(Document d)  { /* ... */ }
}

record Document(String name) {}




/*  Exercise-5  ‚ñ∏  DEPENDENCY-INVERSION  (DIP)
 *  High-level `Switch` depends directly on the concrete `Lamp`.
 *  TODO: Introduce an abstraction so Switch can control any device.
 */


public interface Lamp {void turnON(): turnOFF();


public class Switch {
    private final Lamp lamp;
    Switch(Lamp l){ this.lamp = l; }
    void toggle(boolean on){
        if(on) lamp.turnOn(); else lamp.turnOff();
    }
}


class Lamp {
    void turnOn()  { System.out.println("üí° on"); }
    void turnOff() { System.out.println("üí° off"); }
}
